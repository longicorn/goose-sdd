このドキュメントの[日本語版](./01_problem_context.md)もあります。

# Context: The Difficulty of "Understanding and Control" in Modern Software Development

## Current Situation: The Gap Between Documentation and Code
In modern development environments, especially in agile and microservice-oriented web development, the difficulty of understanding the product has become a major issue. It is not uncommon to find development sites where this has become an "unsolvable chronic disease" due to a lack of documentation, reliance on oral tradition from project members, or discrepancies between existing documents and the actual code.

*   **Absence and Formalization of Documentation:** The heavyweight specifications of the waterfall era were avoided as they hindered development speed. On the other hand, under the banner of agile, "working software" was prioritized, leading to documentation being neglected or ignored.
*   **The Despair of Onboarding:** Developers new to a product are forced to read code with unclear requirements and specifications. As a result, they either spend years understanding the existing complexity or end up producing context-deficient, dirty code that "works without understanding the background."

This vicious cycle keeps the system in a perpetually incomplete, "half-broken" state, where no one can grasp the full picture.

## The Rise of Vibe Coding and Understanding Debt

The emergence of AI coding assistants and "Vibe Coding" has improved superficial productivity but has exacerbated the core problem.

*   **Vague Instructions and Code That Just Works:** AI quickly generates code from natural language instructions. However, the result is a mass production of code based on ambiguous instructions that merely functions, leading to an unmanageable state where the code's behavior cannot be guaranteed as development progresses. This might be similar to the work of inexperienced developers.
*   **Lack of Intent:** Furthermore, the "why it was designed that way" is not recorded. While features are implemented rapidly during the development phase, the intent is not documented, making it impossible to understand later. This becomes another cause of the aforementioned unmanageable state, making modifications difficult. This is similar to the situation where a lack of documentation leads to producing code that just works.
*   **Collapse of Reviews:** The massive number of small Pull Requests generated by AI overwhelms the cognitive capacity and review speed of human reviewers.
*   **Accumulation of Understanding Debt:** Consequently, "code written by AI" that no one can explain accumulates, and "understanding debt," as opposed to technical debt, grows exponentially. Ultimately, humans lose control of the system.

## Limitations of Existing Solutions (SDD)

Specification-Driven Development (SDD) was conceived as a countermeasure to this situation, but existing tools and methods seem to have the following flaws:

### The Inflexibility of a One-Way Street
Many existing SDD tools only support unidirectional generation from `Spec -> Code`. However, in real-world development (especially for existing products), specifications often change due to discoveries during implementation, and there are many situations where specs should be reverse-engineered from the code.

### Barriers to Adoption
While existing SDD tools are powerful for generating from scratch, they are either powerless against large, complex, existing codebases or their implementation costs are too prohibitive to be functional.
Also, many of these tools are based on the premise that they run with tools like Claude Code, Gemini CLI, or Codex CLI, which for me, forces an undesirable situation of using a UI-based tool.

### The Pain of Control
When trying to delegate everything to a fully autonomous agent, humans have to expend significant effort to monitor and correct the AI's "hallucinations" or "runaway" behavior. This is mentally more taxing than coding itself.

## Conclusion: The Problems `goose-sdd` Aims to Solve

The functionality I want to provide with `goose-sdd` aims to meet the following requirements:

-   The cost of adapting and introducing `goose-sdd` should be minimal, regardless of whether it's for a new or existing product.
-   It should operate solely on the command line, without relying on specific existing CLI tools.
-   **Living Document:** Minimize the cost of document generation and prevent obsolescence, keeping the documentation in a **"Living Document"** state.
-   **Persistence of Context:** Treat not just the code but also the documentation (specifications and intent) as the source of truth, thereby paying off the "understanding debt" of the AI era.
-   **Bidirectional Synchronization:** Establish a flow not only from `Spec -> Code` (To-Be) but also from `Code -> Spec` (As-Is), allowing for a process that moves toward the ideal while organizing the current state.
-   **Collaboration at the Right Granularity:** It should not be a fully automated black box. Instead, it should be a user-friendly tool that separates design and implementation at each stage, keeps operations light, and allows humans to move forward reliably through "conversation" via CLI.
