# Context: 現代ソフトウェア開発における「理解と制御」の困難さ

## 現状認識: ドキュメントとコードの乖離
現代の開発現場、特に分かりやすいのはWeb開発現場のアジャイル開発やマイクロサービス化が進んだ環境において、プロダクトの理解の困難さが大きな問題となっている。ドキュメントが無い、プロジェクトメンバーからの口頭伝授のみ、ドキュメントは存在してもコードの乖離などにより「解決不能な慢性疾患」として定着している開発現場は珍しくない

* ドキュメントの不在、形骸化: ウォーターフォール時代の重厚長大な仕様書は開発速度を阻害するため敬遠され、一方でアジャイルの名の下に「動くソフトウェア」が優先された結果、ドキュメントは軽視・無視されるようになった。
* オンボーディングの絶望: 新たにプロダクトに参加した開発者は、要求や仕様が不明瞭な状態でコードリーディングを強いられる。結果として、既存の複雑さを理解するのに年単位の時間を要するか、あるいは「背景を理解せずとも動く」だけの、文脈を欠いた汚いコード（Dirty Code）を生産し続けることになる。

この悪循環により、システムは常に不完全で、誰も全体像を把握できていない「半分壊れた状態」で運用され続けている。

## Vibe Coding の台頭と理解負債

AIコーディングアシスタントの登場と Vibe Coding は、表層的な生産性を向上させた一方で、問題の本質をより深刻化させた。

* 曖昧な指示と動作するだけのコード: AIは自然言語の指示から素早くコードを生成するが、そこには曖昧な指示と動くだけのコードが大量生産される結果、開発が進むとコードの動作が保証できなくなり管理不能に陥る。これは経験不足の開発者やと似ているかもしれない。
* 意図の欠落: またそこには「なぜそう設計したか」という意図の記録が欠如している。開発段階では高速に機能実装が進むが意図が記録されず後から理解ができずこれも前述の管理不能に陥り修正が困難になる原因の1つとなる。これはドキュメント不足による動くだけのコードを生み出す状況と似ているだろう。
* レビューの崩壊: AIによって量産される小さなPull Requestに対し、人間のレビュワーの認知能力とレビュー速度が追いつかない状態を生み出す。
* 理解負債の蓄積: 結果として、誰も経緯を説明できない「AIが書いたコード」が積み上がり、技術的負債ならぬ「理解負債」が指数関数的に増大する。最終的に、人間はそのシステムを制御できなくなる。

## 既存の解決策（SDD）の限界

この状況への対抗策として SDD(Spec-Driven Development : 仕様駆動開発) が考え出さたが、既存のツールや手法には以下の欠陥があるように感じる。

### 一方通行の不自由さ
既存の SDD ツールの多くは `Spec -> Code` の片方向生成のみをサポートしている。しかし、現実の開発（特に既存プロダクト）では、実装中の発見により仕様が変更されることや、コードから仕様を逆算すべき場面が多々ある。

### 導入の障壁
既存の SDD ツールは何もない状態からの生成には強いが、既に存在する巨大で複雑なコードベースに対しては無力であるか、導入コストが大げさすぎて機能しない。
また、これらのツールの多くは Claude Code, Gemini CLI, Codex CLI 等で動作するという前提に基づいているため、私にとってはUIを伴うツールの強制という好ましくない状況になる。

### 制御の苦痛
完全自律型のエージェントにすべてを任せようとすると、人間はAIの「幻覚」や「暴走」を監視・修正するために多大な労力を払うことになる。これはコーディングそのものよりも精神的負荷が高い。

## 結論： `goose-sdd` が解決したい課題

私が `goose-sdd` 提供したい機能は、以下の要件を満たすのを目標とする

- 新規プロダクト、既存プロダクトに関わらず `goose-sdd` の適応、導入コストは最低限にしたい。
- 既存の特定CLIツールの利用を行わずコマンドラインのみで動作すること。
- Living Document: ドキュメント生成コストの最小化と陳腐化を防ぎドキュメントを **Living Document** の状態にする。
- コンテキストの永続化: コードだけでなく、ドキュメント（仕様・意図）を正として扱い、AI時代の「理解負債」を返済する。
- 双方向の同期: `Spec -> Code` (To-Be) だけでなく、`Code -> Spec` (As-Is) の流れを確立し、現状を整理しながら理想へ向かうプロセスを許容する。
- 適切な粒度での協働: 全自動のブラックボックスではなく、各段階の設計と実装を分離し動作を軽くし、人間がCLI等を通じて「会話」しながら確実に前進できる、扱いやすいツールであること。
